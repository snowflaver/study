// 평행
// 문제 설명
// 점 네 개의 좌표를 담은 이차원 배열  dots가 다음과 같이 매개변수로 주어집니다.
// 4개의 점이 'dots'배열로 받음

// [[x1, y1], [x2, y2], [x3, y3], [x4, y4]]
// 주어진 네 개의 점을 두 개씩 이었을 때,
// 두 직선이 평행이 되는 경우가 있으면 1을 없으면 0을 return 하도록 solution 함수를 완성해보세요.
    // 4개의 점을 2개씩 짝지어 선으로 만들고, 두개의 선이 평행할때 1, 아니면 0으로 반환

// 제한사항
// dots의 길이 = 4
// dots의 원소는 [x, y] 형태이며 x, y는 정수입니다.
// 0 ≤ x, y ≤ 100
// 서로 다른 두개 이상의 점이 겹치는 경우는 없습니다.
    // 입력을 받은 값으로 점을 찍을때 겹치는 일이 없음!
// 두 직선이 겹치는 경우(일치하는 경우)에도 1을 return 해주세요.
    // 두개의 선이 겹쳐도 평행으로 인정하고 1을 반환
// 임의의 두 점을 이은 직선이 x축 또는 y축과 평행한 경우는 주어지지 않습니다.
    // 점 두개씩 짝지엇을때 x축 혹은 y축과 평행하는 일은 없다.

// 입출력 예
// dots	result
// [[1, 4], [9, 2], [3, 8], [11, 6]]	1
// [[3, 5], [4, 1], [2, 4], [5, 10]]	0
// 입출력 예 설명
// 입출력 예 #1

// 점 [1, 4], [3, 8]을 잇고 [9, 2], [11, 6]를 이으면 두 선분은 평행합니다.
// 입출력 예 #2

// 점을 어떻게 연결해도 평행하지 않습니다.

// function solution(dots) {
//     // 점 쌍별로 선분의 기울기를 계산하여 line 배열에 모음
//     let line = dots.flatMap((p1, i) =>
//         dots.slice(i + 1).map(p2 => get_slope(p1, p2))
//     );
//     // 기울기가 같은 선분 쌍을 찾아내어 parallel 배열에 모음
//     let parallel = line.flatMap((slope1, i) =>
//         line.slice(i + 1).filter(slope2 => slope1 === slope2)
//     );
//     // parallel 배열에 요소가 하나 이상이면 1을 반환, 그렇지 않으면 0을 반환
//     return parallel.length > 0 ? 1 : 0;
// }
// function get_slope(p1, p2) {
//     // x좌표가 같을때(분모가 같을때)
//     if (p1[0] === p2[0]) {
//         return Infinity
//     }
//     // 분자(y축) / 분모(x축) 
//     return (p1[1] - p2[1]) / (p1[0] - p2[0])
// }

// console.log(solution([[1, 4], [9, 2], [3, 8], [11, 6]]))    // 1
// console.log(solution([[3, 5], [4, 1], [2, 4], [5, 10]]))    // 0
// console.log(solution([[1, 4], [9, 2], [3, 5], [4, 1]]))    // 0

// 해설================================================================

// 주어진 4개의 점을 이용해서 2개씩 짝지어 모든 선의 기울기를 구하고
// 기울기가 같은 선이 있는지 확인하기 위해서 'flatMap'메서드를 사용해서 중첩된 배열을 새롭게 받아서
// 평탄화 해주는 작업을 먼저 실행

// 첫번째 'line'에서의 'flatMap'메서 'slice'메서드를 사용해서 주어진 배열의 일부분을 추출해서
// 점의 쌍 '[p1, p2]'일때 'slice'메서드는 'dots'배열에서 'p2'와 그 이후의 점으로 이루어진 부분배열을 추출
// 여기서 'map'메서드를 이용해서 'p1'과 'p2'를 짝지어 이은 선의 기울기를 구함

// 이렇게 구해진 모든 선의 기울기가 'line'에 저장

// 두번째 평행을 뜻하는 'parallel'에서의 'flatMap'은 이전에 만들어둔 'line'배열의 모든 요소들은 여러번 반복하면서
// 기울기가 같은 경우를 서치하고 이때 'filter'를 사용해서 기울기가 같은 중복된 경우를 제거

// 마지막으로 x좌표가 같을때 선의 기울기는 없으므로 'Infinity'를 사용해서 제외시키고
// 제외시킨 나머지를 반환 해준다.
    
    // 해당 코드는 제출햇을때 통과 못함

    // function solution(dots) {
    //     const line = []
    //     for(let i = 0 ; i < dots.length ; i ++) {
    //         for(let j = i+1 ; j < dots.length ; j ++) {
    //             const parallel = (dots[i][1]-dots[j][1]) / (dots[i][0]-dots[j][0])
    //             if(line.includes(parallel)) return 1
    //             line.push(parallel)
    //         }
    //     }
    //     return 0
    // }

    function solution(dots) {
        let [a,b,c,d] = dots;
    
        let ab = (a[0]-b[0]) / (a[1]-b[1]);
        let ac = (a[0]-c[0]) / (a[1]-c[1]);
        let ad = (a[0]-d[0]) / (a[1]-d[1]);
        let bc = (b[0]-c[0]) / (b[1]-c[1]);
        let bd = (b[0]-d[0]) / (b[1]-d[1]);
        let cd = (c[0]-d[0]) / (c[1]-d[1]);
    
        let answer = ( ab === cd || ac === bd )?1:0;
        return answer;
    }